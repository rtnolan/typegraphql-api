"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const child_process_1 = require("child_process");
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default('getos');
const readFile = util_1.promisify(fs_1.default.readFile);
const exists = util_1.promisify(fs_1.default.exists);
async function getos() {
    const platform = os_1.default.platform();
    if (platform !== 'linux') {
        return {
            platform,
        };
    }
    return {
        platform: 'linux',
        libssl: await getOpenSSLVersion(),
        distro: await resolveDistro(),
    };
}
exports.getos = getos;
function parseDistro(input) {
    const idRegex = /^ID="?([^"\n]*)"?$/im;
    const idLikeRegex = /^ID_LIKE="?([^"\n]*)"?$/im;
    const idMatch = input.match(idRegex);
    const id = (idMatch && idMatch[1] && idMatch[1].toLowerCase()) || '';
    const idLikeMatch = input.match(idLikeRegex);
    const idLike = (idLikeMatch && idLikeMatch[1] && idLikeMatch[1].toLowerCase()) || '';
    if (idLike.includes('centos') ||
        idLike.includes('fedora') ||
        idLike.includes('rhel') ||
        id === 'fedora') {
        return 'rhel';
    }
    if (idLike.includes('debian') ||
        idLike.includes('ubuntu') ||
        id === 'debian') {
        return 'debian';
    }
    return;
}
exports.parseDistro = parseDistro;
async function resolveDistro() {
    const osReleaseFile = '/etc/os-release';
    if (!(await exists(osReleaseFile))) {
        return;
    }
    const file = await readFile(osReleaseFile, 'utf-8');
    return parseDistro(file);
}
exports.resolveDistro = resolveDistro;
function parseOpenSSLVersion(input) {
    const match = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(input);
    if (match) {
        return match[1] + '.x';
    }
    return;
}
exports.parseOpenSSLVersion = parseOpenSSLVersion;
// getOpenSSLVersion returns the OpenSSL version excluding the patch version, e.g. "1.1.x"
async function getOpenSSLVersion() {
    const [version, ls] = await Promise.all([
        gracefulExec(`openssl version -v`),
        gracefulExec(`
      ls -l /lib64 | grep ssl;
      ls -l /usr/lib64 | grep ssl;
    `),
    ]);
    debug({ version });
    debug({ ls });
    if (version) {
        const v = parseOpenSSLVersion(version);
        if (v) {
            return v;
        }
    }
    if (ls) {
        const match = /libssl\.so\.(\d+\.\d+)\.\d+/.exec(ls);
        if (match) {
            return match[1] + '.x';
        }
    }
    return undefined;
}
exports.getOpenSSLVersion = getOpenSSLVersion;
async function gracefulExec(cmd) {
    return new Promise(resolve => {
        try {
            child_process_1.exec(cmd, (err, stdout, stderr) => {
                resolve(String(stdout));
            });
        }
        catch (e) {
            resolve(undefined);
            return undefined;
        }
    });
}
async function getPlatform() {
    const { platform, libssl, distro } = await getos();
    debug({ platform, libssl });
    if (platform === 'darwin') {
        return 'darwin';
    }
    if (platform === 'win32') {
        return 'windows';
    }
    // when the platform is linux
    if (platform === 'linux' && distro && libssl) {
        return (distro + '-openssl-' + libssl);
    }
    // if just OpenSSL is known, fallback to debian with a specific libssl version
    if (libssl) {
        return ('debian-openssl-' + libssl);
    }
    // if just the distro is known, fallback to latest OpenSSL 1.1
    if (distro) {
        return (distro + '-openssl-1.1.x');
    }
    // use the debian build with OpenSSL 1.1 as a last resort
    return 'debian-openssl-1.1.x';
}
exports.getPlatform = getPlatform;
//# sourceMappingURL=getPlatform.js.map