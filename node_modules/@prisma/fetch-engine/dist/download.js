"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const chalk_1 = __importDefault(require("chalk"));
// Packages
const path_1 = __importDefault(require("path"));
const debug_1 = __importDefault(require("debug"));
const make_dir_1 = __importDefault(require("make-dir"));
const execa_1 = __importDefault(require("execa"));
const p_filter_1 = __importDefault(require("p-filter"));
const hasha_1 = __importDefault(require("hasha"));
// Utils
const log_1 = require("./log");
const chmod_1 = __importDefault(require("./chmod"));
const copy_1 = require("./copy");
const get_platform_1 = require("@prisma/get-platform");
const downloadZip_1 = require("./downloadZip");
const util_2 = require("./util");
const cleanupCache_1 = require("./cleanupCache");
const flatMap_1 = require("./flatMap");
const getLatestAlphaTag_1 = require("./getLatestAlphaTag");
const debug = debug_1.default('download');
const writeFile = util_1.promisify(fs_1.default.writeFile);
const exists = util_1.promisify(fs_1.default.exists);
const readFile = util_1.promisify(fs_1.default.readFile);
const channel = 'master';
const binaryToEnvVar = {
    'migration-engine': 'PRISMA_MIGRATION_ENGINE_BINARY',
    'query-engine': 'PRISMA_QUERY_ENGINE_BINARY',
    'introspection-engine': 'PRISMA_INTROSPECTION_ENGINE_BINARY',
};
async function download(options) {
    // get platform
    const platform = await get_platform_1.getPlatform();
    // no need to do anything, if there are no binaries
    if (!options.binaries || Object.values(options.binaries).length === 0) {
        return {};
    }
    if (options.binaryTargets && Array.isArray(options.binaryTargets)) {
        const unknownTargets = options.binaryTargets.filter(t => !get_platform_1.platforms.includes(t));
        if (unknownTargets.length > 0) {
            throw new Error(`Unknown binaryTargets ${unknownTargets.join(', ')}`);
        }
    }
    // merge options
    options = {
        binaryTargets: [platform],
        version: 'latest',
        ...options,
        binaries: mapKeys(options.binaries, key => engineTypeToBinaryType(key, platform)),
    };
    const binaryJobs = flatMap_1.flatMap(Object.entries(options.binaries), ([binaryName, targetFolder]) => options.binaryTargets.map(binaryTarget => {
        const fileName = getBinaryName(binaryName, binaryTarget);
        return {
            binaryName,
            targetFolder,
            binaryTarget,
            fileName,
            targetFilePath: path_1.default.join(targetFolder, fileName),
            envVarPath: getBinaryEnvVarPath(binaryName),
        };
    }));
    if (options.version === 'latest') {
        options.version = await getLatestAlphaTag_1.getLatestAlphaTag();
    }
    if (options.printVersion) {
        console.log(`version: ${options.version}`);
    }
    // filter out files, which don't yet exist or have to be created
    const binariesToDownload = await p_filter_1.default(binaryJobs, async (job) => {
        const needsToBeDownloaded = await binaryNeedsToBeDownloaded(job, platform, options.version, options.failSilent);
        debug({ needsToBeDownloaded });
        return !job.envVarPath && (options.ignoreCache || needsToBeDownloaded);
    });
    if (binariesToDownload.length > 0) {
        const cleanupPromise = cleanupCache_1.cleanupCache(); // already start cleaning up while we download
        let finishBar;
        let setProgress;
        if (options.showProgress) {
            const collectiveBar = getCollectiveBar(options);
            finishBar = collectiveBar.finishBar;
            setProgress = collectiveBar.setProgress;
        }
        await Promise.all(binariesToDownload.map(job => downloadBinary({
            ...job,
            version: options.version,
            failSilent: options.failSilent,
            progressCb: setProgress ? setProgress(job.targetFilePath) : undefined,
        })));
        await cleanupPromise; // make sure, that cleanup finished
        if (finishBar) {
            finishBar();
        }
    }
    return binaryJobsToBinaryPaths(binaryJobs);
}
exports.download = download;
function getCollectiveBar(options) {
    const bar = log_1.getBar(`Downloading Prisma engines for ${options.binaryTargets.map(p => chalk_1.default.bold(p)).join(' and ')}`);
    const progressMap = {};
    // Object.values is faster than Object.keys
    const numDownloads = Object.values(options.binaries).length * Object.values(options.binaryTargets).length;
    const setProgress = (sourcePath) => progress => {
        progressMap[sourcePath] = progress;
        const progressValues = Object.values(progressMap);
        const totalProgress = progressValues.reduce((acc, curr) => {
            return acc + curr;
        }, 0) / numDownloads;
        if (options.progressCb) {
            options.progressCb(totalProgress);
        }
        if (bar) {
            bar.update(totalProgress);
        }
    };
    return {
        setProgress,
        finishBar: () => {
            bar.update(1);
            bar.terminate();
        },
    };
}
function binaryJobsToBinaryPaths(jobs) {
    return jobs.reduce((acc, job) => {
        if (!acc[job.binaryName]) {
            acc[job.binaryName] = {};
        }
        // if an env var path has been provided, prefer that one
        acc[job.binaryName][job.binaryTarget] = job.envVarPath || job.targetFilePath;
        return acc;
    }, {});
}
async function binaryNeedsToBeDownloaded(job, nativePlatform, version, failSilent) {
    // 1. Check if file exists
    const targetExists = await exists(job.targetFilePath);
    // 2. If exists, check, if cached file exists and is up to date and has same hash as file.
    // If not, copy cached file over
    const cachedFile = await getCachedBinaryPath({
        ...job,
        version,
        failSilent,
    });
    debug({ fileExists: targetExists, cachedFile });
    if (cachedFile) {
        debug({ cachedFile });
        const sha256FilePath = cachedFile + '.sha256';
        if (await exists(sha256FilePath)) {
            const sha256File = await readFile(sha256FilePath, 'utf-8');
            const sha256Cache = await hasha_1.default.fromFile(cachedFile, { algorithm: 'sha256' });
            debug({ sha256File, sha256Cache, cachedFile, sha256FilePath });
            if (sha256File === sha256Cache) {
                if (!targetExists) {
                    await copy_1.copy(cachedFile, job.targetFilePath);
                }
                const targetSha256 = await hasha_1.default.fromFile(job.targetFilePath, { algorithm: 'sha256' });
                debug({ targetSha256 });
                if (sha256File !== targetSha256) {
                    debug(`sha256 of target file is incorrect, therefore it's corrupt and we need to copy it over again.`);
                    await copy_1.copy(cachedFile, job.targetFilePath);
                }
                else {
                    debug(`sha256 of target is correct, so there's nothing to do :)`);
                }
                return false;
            }
            else {
                debug(`Cached sha256 is not correct!`);
                debug(`Took it from ${sha256FilePath}`);
                return true;
            }
        }
        else {
            debug(`No sha256 exists for ${cachedFile}. Looked at ${sha256FilePath}`);
            return true;
        }
    }
    // If there is no cache and the file doesn't exist, we for sure need to download it
    if (!targetExists) {
        return true;
    }
    // 3. If same platform, always check --version
    if (job.binaryTarget === nativePlatform) {
        const works = await checkVersionCommand(job.targetFilePath);
        debug({ works });
        return !works;
    }
    return false;
}
async function getVersion(enginePath) {
    const result = await execa_1.default(enginePath, ['--version']);
    debug(`Getting version of ${enginePath}. Result: `, result);
    return result.stdout;
}
exports.getVersion = getVersion;
async function checkVersionCommand(enginePath) {
    try {
        const version = await getVersion(enginePath);
        debug(`Getting version of ${enginePath}. Result: `, version);
        return version.length > 0;
    }
    catch (e) {
        debug(`Version command does not work`, e);
        return false;
    }
}
exports.checkVersionCommand = checkVersionCommand;
function getBinaryName(binaryName, platform) {
    const extension = platform === 'windows' ? '.exe' : '';
    return `${binaryName}-${platform}${extension}`;
}
exports.getBinaryName = getBinaryName;
async function getCachedBinaryPath({ version, binaryTarget, binaryName, }) {
    const cacheDir = await util_2.getCacheDir(channel, version, binaryTarget);
    if (!cacheDir) {
        return null;
    }
    const cachedTargetPath = path_1.default.join(cacheDir, binaryName);
    if (!fs_1.default.existsSync(cachedTargetPath)) {
        return null;
    }
    // All versions not called 'latest' are unique
    // only latest needs more checks
    if (version !== 'latest') {
        return cachedTargetPath;
    }
    if (await exists(cachedTargetPath)) {
        return cachedTargetPath;
    }
    return null;
}
function getBinaryEnvVarPath(binaryName) {
    const envVar = binaryToEnvVar[binaryName];
    if (envVar && process.env[envVar]) {
        const envVarPath = path_1.default.resolve(process.cwd(), process.env[envVar]);
        if (!fs_1.default.existsSync(envVarPath)) {
            throw new Error(`Env var ${chalk_1.default.bold(envVar)} is provided but provided path ${chalk_1.default.underline(process.env[envVar])} can't be resolved.`);
        }
        debug(`Using env var ${chalk_1.default.bold(envVar)} for binary ${chalk_1.default.bold(binaryName)}, which points to ${chalk_1.default.underline(process.env[envVar])}`);
        return envVarPath;
    }
    return null;
}
exports.getBinaryEnvVarPath = getBinaryEnvVarPath;
async function downloadBinary(options) {
    const { version, progressCb, targetFilePath, binaryTarget, binaryName } = options;
    const downloadUrl = util_2.getDownloadUrl(channel, version, binaryTarget, binaryName);
    const targetDir = path_1.default.dirname(targetFilePath);
    try {
        fs_1.default.accessSync(targetDir, fs_1.default.constants.W_OK);
        await make_dir_1.default(targetDir);
    }
    catch (e) {
        if (options.failSilent || e.code !== 'EACCES') {
            return;
        }
        else {
            throw new Error(`Can't write to ${targetDir} please make sure you install "@prisma/cli" with the right permissions.`);
        }
    }
    debug(`Downloading ${downloadUrl} to ${targetFilePath}`);
    if (progressCb) {
        progressCb(0);
    }
    debug(`Downloading zip`);
    const { sha256, zippedSha256 } = await downloadZip_1.downloadZip(downloadUrl, targetFilePath, progressCb);
    if (progressCb) {
        progressCb(1);
    }
    if (process.platform !== 'win32') {
        chmod_1.default(targetFilePath);
    }
    // Cache result
    await saveFileToCache(options, version, sha256, zippedSha256);
}
async function saveFileToCache(job, version, sha256, zippedSha256) {
    // always fail silent, as the cache is optional
    const cacheDir = await util_2.getCacheDir(channel, version, job.binaryTarget);
    if (!cacheDir) {
        return;
    }
    const cachedTargetPath = path_1.default.join(cacheDir, job.binaryName);
    const cachedSha256Path = path_1.default.join(cacheDir, job.binaryName + '.sha256');
    const cachedSha256ZippedPath = path_1.default.join(cacheDir, job.binaryName + '.gz.sha256');
    try {
        await copy_1.copy(job.targetFilePath, cachedTargetPath);
        await writeFile(cachedSha256Path, sha256);
        await writeFile(cachedSha256ZippedPath, zippedSha256);
    }
    catch (e) {
        debug(e);
        // let this fail silently - the CI system may have reached the file size limit
    }
}
function engineTypeToBinaryType(engineType, binaryTarget) {
    if (engineType === 'introspectionEngine') {
        return 'introspection-engine';
    }
    if (engineType === 'migrationEngine') {
        return 'migration-engine';
    }
    if (engineType === 'queryEngine') {
        return 'query-engine';
    }
    if (engineType === 'native') {
        return binaryTarget;
    }
    return engineType;
}
function mapKeys(obj, mapper) {
    return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[mapper(key)] = value;
        return acc;
    }, {});
}
//# sourceMappingURL=download.js.map