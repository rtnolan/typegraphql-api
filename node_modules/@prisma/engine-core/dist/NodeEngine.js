"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Engine_1 = require("./Engine");
const debug_1 = __importDefault(require("debug"));
const get_platform_1 = require("@prisma/get-platform");
const path_1 = __importDefault(require("path"));
const net_1 = __importDefault(require("net"));
const fs_1 = __importDefault(require("fs"));
const chalk_1 = __importDefault(require("chalk"));
const printGeneratorConfig_1 = require("./printGeneratorConfig");
const util_1 = require("./util");
const util_2 = require("util");
const events_1 = __importDefault(require("events"));
const log_1 = require("./log");
const child_process_1 = require("child_process");
const byline_1 = __importDefault(require("./byline"));
const bent_1 = __importDefault(require("bent"));
const debug = debug_1.default('engine');
const exists = util_2.promisify(fs_1.default.exists);
const readdir = util_2.promisify(fs_1.default.readdir);
/**
 * Node.js based wrapper to run the Prisma binary
 */
const knownPlatforms = [
    'native',
    'darwin',
    'debian-openssl-1.0.x',
    'debian-openssl-1.1.x',
    'rhel-openssl-1.0.x',
    'rhel-openssl-1.1.x',
    'windows',
];
const children = [];
class NodeEngine {
    constructor({ cwd, datamodelPath, prismaPath, generator, datasources, showColors, logLevel, logQueries, env, flags, ...args }) {
        /**
         * exiting is used to tell the .on('exit') hook, if the exit came from our script.
         * As soon as the Prisma binary returns a correct return code (like 1 or 0), we don't need this anymore
         */
        this.exiting = false;
        this.managementApiEnabled = false;
        this.ready = false;
        this.stderrLogs = '';
        this.stdoutLogs = '';
        this.fail = async (e, why) => {
            debug(e, why);
            await this.stop();
        };
        this.env = env;
        this.cwd = this.resolveCwd(cwd);
        this.debug = args.debug || false;
        this.datamodelPath = datamodelPath;
        this.prismaPath = process.env.PRISMA_QUERY_ENGINE_BINARY || prismaPath;
        this.generator = generator;
        this.datasources = datasources;
        this.logEmitter = new events_1.default();
        this.showColors = showColors || false;
        this.logLevel = logLevel;
        this.logQueries = logQueries || false;
        this.flags = flags || [];
        this.logEmitter.on('error', (log) => {
            if (this.debug) {
                debug_1.default('engine:log')(log);
            }
            this.lastErrorLog = log;
            if (log.fields.message === 'PANIC') {
                this.handlePanic(log);
            }
        });
        if (this.platform) {
            if (!knownPlatforms.includes(this.platform) && !fs_1.default.existsSync(this.platform)) {
                throw new Engine_1.PrismaClientInitializationError(`Unknown ${chalk_1.default.red('PRISMA_QUERY_ENGINE_BINARY')} ${chalk_1.default.redBright.bold(this.platform)}. Possible binaryTargets: ${chalk_1.default.greenBright(knownPlatforms.join(', '))} or a path to the query engine binary.
You may have to run ${chalk_1.default.greenBright('prisma generate')} for your changes to take effect.`);
            }
        }
        else {
            this.getPlatform();
        }
        if (this.debug) {
            debug_1.default.enable('*');
        }
    }
    resolveCwd(cwd) {
        if (cwd && fs_1.default.existsSync(cwd) && fs_1.default.lstatSync(cwd).isDirectory()) {
            return cwd;
        }
        return process.cwd();
    }
    on(event, listener) {
        this.logEmitter.on(event, listener);
    }
    async getPlatform() {
        if (this.platformPromise) {
            return this.platformPromise;
        }
        this.platformPromise = get_platform_1.getPlatform();
        return this.platformPromise;
    }
    getQueryEnginePath(platform, prefix = __dirname) {
        let queryEnginePath = path_1.default.join(prefix, `query-engine-${platform}`);
        if (platform === 'windows') {
            queryEnginePath = `${queryEnginePath}.exe`;
        }
        return queryEnginePath;
    }
    handlePanic(log) {
        this.child.kill();
        if (this.currentRequestPromise) {
            ;
            this.currentRequestPromise.cancel();
        }
    }
    async resolvePrismaPath() {
        if (this.prismaPath) {
            return this.prismaPath;
        }
        const platform = await this.getPlatform();
        if (this.platform && this.platform !== platform) {
            this.incorrectlyPinnedPlatform = this.platform;
        }
        this.platform = this.platform || platform;
        const fileName = eval(`require('path').basename(__filename)`);
        if (fileName === 'NodeEngine.js') {
            return this.getQueryEnginePath(this.platform, path_1.default.resolve(__dirname, `..`));
        }
        else {
            return this.getQueryEnginePath(this.platform);
        }
    }
    // get prisma path
    async getPrismaPath() {
        const prismaPath = await this.resolvePrismaPath();
        const platform = await this.getPlatform();
        // If path to query engine doesn't exist, throw
        if (!(await exists(prismaPath))) {
            const pinnedStr = this.incorrectlyPinnedPlatform
                ? `\nYou incorrectly pinned it to ${chalk_1.default.redBright.bold(`${this.incorrectlyPinnedPlatform}`)}\n`
                : '';
            const dir = path_1.default.dirname(prismaPath);
            let errorText = `Query engine binary for current platform "${chalk_1.default.bold(platform)}" could not be found.${pinnedStr}
This probably happens, because you built Prisma Client on a different platform.
(Prisma Client looked in "${chalk_1.default.underline(prismaPath)}")`;
            // The generator should always be there during normal usage
            if (this.generator) {
                // The user already added it, but it still doesn't work 🤷‍♀️
                // That means, that some build system just deleted the files 🤔
                if (this.generator.binaryTargets.includes(this.platform) || this.generator.binaryTargets.includes('native')) {
                    let files = [];
                    if (fs_1.default.existsSync(dir)) {
                        files = await readdir(dir);
                    }
                    errorText += `\n\nFiles in ${dir}:

${files.map((f) => `  ${f}`).join('\n')}\n
You already added the platform${this.generator.binaryTargets.length > 1 ? 's' : ''} ${this.generator.binaryTargets
                        .map((t) => `"${chalk_1.default.bold(t)}"`)
                        .join(', ')} to the "${chalk_1.default.underline('generator')}" block
in the "schema.prisma" file as described in https://pris.ly/d/client-generator,
but something went wrong. That's suboptimal.

Please create an issue at https://github.com/prisma/prisma-client-js/issues/new`;
                }
                else {
                    // If they didn't even have the current running platform in the schema.prisma file, it's easy
                    // Just add it
                    errorText += `\n\nTo solve this problem, add the platform "${this.platform}" to the "${chalk_1.default.underline('generator')}" block in the "schema.prisma" file:
${chalk_1.default.greenBright(this.getFixedGenerator())}

Then run "${chalk_1.default.greenBright('prisma generate')}" for your changes to take effect.
Read more about deploying Prisma Client: https://pris.ly/d/client-generator`;
                }
            }
            else {
                errorText += `\n\nRead more about deploying Prisma Client: https://pris.ly/d/client-generator\n`;
            }
            throw new Engine_1.PrismaClientInitializationError(errorText);
        }
        if (this.incorrectlyPinnedPlatform) {
            console.log(`${chalk_1.default.yellow('Warning:')} You pinned the platform ${chalk_1.default.bold(this.incorrectlyPinnedPlatform)}, but Prisma Client detects ${chalk_1.default.bold(await this.getPlatform())}.
This means you should very likely pin the platform ${chalk_1.default.greenBright(await this.getPlatform())} instead.
${chalk_1.default.dim("In case we're mistaken, please report this to us 🙏.")}`);
        }
        if (process.platform !== 'win32') {
            util_1.plusX(prismaPath);
        }
        return prismaPath;
    }
    getFixedGenerator() {
        const fixedGenerator = {
            ...this.generator,
            binaryTargets: util_1.fixPlatforms(this.generator.binaryTargets, this.platform),
        };
        return printGeneratorConfig_1.printGeneratorConfig(fixedGenerator);
    }
    printDatasources() {
        if (this.datasources) {
            return JSON.stringify(this.datasources);
        }
        return '[]';
    }
    /**
     * Starts the engine, returns the url that it runs on
     */
    async start() {
        if (!this.startPromise) {
            this.startPromise = this.internalStart();
        }
        return this.startPromise;
    }
    internalStart() {
        return new Promise(async (resolve, reject) => {
            try {
                this.port = await this.getFreePort();
                const env = {
                    PRISMA_DML_PATH: this.datamodelPath,
                    PORT: String(this.port),
                    RUST_BACKTRACE: '1',
                    RUST_LOG: 'info',
                };
                if (this.logQueries || this.logLevel === 'info') {
                    env.RUST_LOG = 'info';
                    if (this.logQueries) {
                        env.LOG_QUERIES = 'true';
                    }
                }
                if (this.logLevel === 'warn') {
                    env.RUST_LOG = 'warn';
                }
                if (this.datasources) {
                    env.OVERWRITE_DATASOURCES = this.printDatasources();
                }
                if (!process.env.NO_COLOR && this.showColors) {
                    env.CLICOLOR_FORCE = '1';
                }
                debug(env);
                debug({ cwd: this.cwd });
                const prismaPath = await this.getPrismaPath();
                const flags = ['--enable-raw-queries', ...this.flags];
                debug({ flags });
                this.child = child_process_1.spawn(prismaPath, flags, {
                    env: {
                        ...this.env,
                        ...process.env,
                        ...env,
                    },
                    cwd: this.cwd,
                    stdio: ['ignore', 'pipe', 'pipe'],
                });
                children.push(this.child);
                byline_1.default(this.child.stderr).on('data', (msg) => {
                    const data = String(msg);
                    debug('stderr', data);
                    try {
                        const json = JSON.parse(data);
                        if (typeof json.is_panic !== 'undefined') {
                            debug(json);
                            this.lastError = json;
                            if (this.engineStartDeferred) {
                                const err = new Engine_1.PrismaClientInitializationError(this.lastError.message);
                                this.engineStartDeferred.reject(err);
                            }
                        }
                    }
                    catch (e) {
                        if (!data.includes('Printing to stderr') && !data.includes('Listening on ')) {
                            this.stderrLogs += '\n' + data;
                        }
                    }
                });
                byline_1.default(this.child.stdout).on('data', (msg) => {
                    var _a;
                    const data = String(msg);
                    try {
                        const json = JSON.parse(data);
                        debug('stdout', json);
                        if (this.engineStartDeferred &&
                            json.level === 'INFO' &&
                            json.target === 'query_engine::server' && ((_a = json.fields) === null || _a === void 0 ? void 0 : _a.message.startsWith('Started http server'))) {
                            this.engineStartDeferred.resolve();
                            this.engineStartDeferred = undefined;
                        }
                        if (typeof json.is_panic === 'undefined') {
                            const log = log_1.convertLog(json);
                            this.logEmitter.emit(log.level, log);
                        }
                        else {
                            this.lastError = json;
                        }
                    }
                    catch (e) {
                        // debug(e, data)
                    }
                });
                this.child.on('exit', (code, signal) => {
                    this.exitCode = code;
                    if (code !== 0 && this.engineStartDeferred) {
                        const err = new Engine_1.PrismaClientInitializationError(this.stderrLogs);
                        this.engineStartDeferred.reject(err);
                    }
                    if (!this.child) {
                        return;
                    }
                    if (this.lastError) {
                        return;
                    }
                    if (this.lastErrorLog) {
                        this.lastErrorLog.target = 'exit';
                        return;
                    }
                    if (code === 126) {
                        this.lastErrorLog = {
                            timestamp: new Date(),
                            target: 'exit',
                            level: 'error',
                            fields: {
                                message: `Couldn't start query engine as it's not executable on this operating system.
You very likely have the wrong "binaryTarget" defined in the schema.prisma file.`,
                            },
                        };
                    }
                    else {
                        this.lastErrorLog = {
                            target: 'exit',
                            timestamp: new Date(),
                            level: 'error',
                            fields: {
                                message: (this.stderrLogs || '') + (this.stdoutLogs || '') + `\nExit code: ${code}`,
                            },
                        };
                    }
                });
                this.child.on('error', (err) => {
                    this.lastError = {
                        message: err.message,
                        backtrace: 'Could not start query engine',
                        is_panic: false,
                    };
                    reject(err);
                });
                this.child.on('close', (code, signal) => {
                    var _a;
                    if (code === null && signal === 'SIGABRT' && this.child) {
                        console.error(`${chalk_1.default.bold.red(`Error in Prisma Client:`)}${this.stderrLogs}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a stack overflow.
Please create an issue in https://github.com/prisma/prisma-client-js describing the last Prisma Client query you called.`);
                    }
                    else if (code === 255 && signal === null && ((_a = this.lastErrorLog) === null || _a === void 0 ? void 0 : _a.fields.message) === 'PANIC') {
                        console.error(`${chalk_1.default.bold.red(`Error in Prisma Client:`)}
${this.lastErrorLog.fields.message}: ${this.lastErrorLog.fields.reason} in
${this.lastErrorLog.fields.file}:${this.lastErrorLog.fields.line}:${this.lastErrorLog.fields.column}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.
Please create an issue in https://github.com/prisma/prisma-client-js describing the last Prisma Client query you called.`);
                    }
                });
                if (this.lastError) {
                    return reject(new Engine_1.PrismaClientInitializationError(Engine_1.getMessage(this.lastError)));
                }
                if (this.lastErrorLog) {
                    return reject(new Engine_1.PrismaClientInitializationError(Engine_1.getMessage(this.lastErrorLog)));
                }
                try {
                    await new Promise((resolve, reject) => {
                        this.engineStartDeferred = { resolve, reject };
                    });
                }
                catch (err) {
                    await this.child.kill();
                    throw err;
                }
                const url = `http://localhost:${this.port}`;
                this.url = url;
                // TODO: Re-enable
                // this.client = new Client(url)
                resolve();
            }
            catch (e) {
                reject(e);
            }
        });
    }
    /**
     * If Prisma runs, stop it
     */
    async stop() {
        await this.start();
        if (this.currentRequestPromise) {
            try {
                await this.currentRequestPromise;
            }
            catch (e) {
                //
            }
        }
        if (this.child) {
            debug(`Stopping Prisma engine`);
            this.exiting = true;
            // this.client.close()
            await this.child.kill();
            delete this.child;
        }
    }
    /**
     * Use the port 0 trick to get a new port
     */
    getFreePort() {
        return new Promise((resolve, reject) => {
            const server = net_1.default.createServer((s) => s.end(''));
            server.unref();
            server.on('error', reject);
            server.listen(0, () => {
                const address = server.address();
                const port = typeof address === 'string' ? parseInt(address.split(':').slice(-1)[0], 10) : address.port;
                server.close((e) => {
                    if (e) {
                        reject(e);
                    }
                    resolve(port);
                });
            });
        });
    }
    /**
     * Make sure that our internal port is not conflicting with the prisma.yml's port
     * @param str config
     */
    trimPort(str) {
        return str
            .split('\n')
            .filter((l) => !l.startsWith('port:'))
            .join('\n');
    }
    async request(query) {
        await this.start();
        if (!this.child) {
            throw new Engine_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`);
        }
        const variables = {};
        const body = {
            query,
            variables,
        };
        const post = bent_1.default(this.url, 'POST', 'json', 200);
        this.currentRequestPromise = post('/', body);
        return this.currentRequestPromise
            .then((data) => {
            if (data.errors) {
                if (data.errors.length === 1) {
                    throw this.graphQLToJSError(data.errors[0]);
                }
                throw new Error(JSON.stringify(data.errorrs));
            }
            return data;
        })
            .catch((error) => {
            debug({ error });
            if (this.currentRequestPromise.isCanceled && this.lastError) {
                // TODO: Replace these errors with known or unknown request errors
                if (this.lastError.is_panic) {
                    throw new Engine_1.PrismaClientRustPanicError(Engine_1.getMessage(this.lastError));
                }
                else {
                    throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastError));
                }
            }
            if (this.currentRequestPromise.isCanceled && this.lastErrorLog) {
                throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastErrorLog));
            }
            if ((error.code && error.code === 'ECONNRESET') || error.code === 'ECONNREFUSED') {
                if (this.lastError) {
                    throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastError));
                }
                if (this.lastErrorLog) {
                    throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastErrorLog));
                }
                const logs = this.stderrLogs || this.stdoutLogs;
                throw new Engine_1.PrismaClientUnknownRequestError(logs);
            }
            throw error;
        });
    }
    async requestBatch(queries) {
        await this.start();
        if (!this.child) {
            throw new Engine_1.PrismaClientUnknownRequestError(`Can't perform request, as the Engine has already been stopped`);
        }
        const variables = {};
        const body = {
            batch: queries.map((query) => ({ query, variables })),
        };
        const post = bent_1.default(this.url, 'POST', 'json', 200);
        this.currentRequestPromise = post('/', body);
        return this.currentRequestPromise
            .then((data) => {
            if (Array.isArray(data)) {
                return data.map((result) => {
                    if (result.errors) {
                        return this.graphQLToJSError(result.errors[0]);
                    }
                    return result;
                });
            }
            else {
                if (data.errors && data.errors.length === 1) {
                    throw new Error(data.errors[0].error);
                }
                throw new Error(JSON.stringify(data));
            }
        })
            .catch((error) => {
            debug({ error });
            if (this.currentRequestPromise.isCanceled && this.lastError) {
                // TODO: Replace these errors with known or unknown request errors
                if (this.lastError.is_panic) {
                    throw new Engine_1.PrismaClientRustPanicError(Engine_1.getMessage(this.lastError));
                }
                else {
                    throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastError));
                }
            }
            if (this.currentRequestPromise.isCanceled && this.lastErrorLog) {
                throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastErrorLog));
            }
            if ((error.code && error.code === 'ECONNRESET') || error.code === 'ECONNREFUSED') {
                if (this.lastError) {
                    throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastError));
                }
                if (this.lastErrorLog) {
                    throw new Engine_1.PrismaClientUnknownRequestError(Engine_1.getMessage(this.lastErrorLog));
                }
                const logs = this.stderrLogs || this.stdoutLogs;
                throw new Engine_1.PrismaClientUnknownRequestError(logs);
            }
            throw error;
        });
    }
    graphQLToJSError(error) {
        if (error.user_facing_error.error_code) {
            return new Engine_1.PrismaClientKnownRequestError(error.user_facing_error.message, error.user_facing_error.error_code, error.user_facing_error.meta);
        }
        return new Engine_1.PrismaClientUnknownRequestError(error.user_facing_error.message);
    }
}
exports.NodeEngine = NodeEngine;
function exitHandler(exit = false) {
    return () => {
        for (const child of children) {
            if (!child.killed) {
                child.kill();
            }
        }
        if (exit) {
            process.exit();
        }
    };
}
process.on('beforeExit', exitHandler());
process.on('exit', exitHandler());
process.on('SIGINT', exitHandler(true));
process.on('SIGUSR1', exitHandler(true));
process.on('SIGUSR2', exitHandler(true));
//# sourceMappingURL=NodeEngine.js.map