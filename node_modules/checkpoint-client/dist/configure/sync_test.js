'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var makeDir = _interopDefault(require('make-dir'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var tempfile = _interopDefault(require('tempfile'));
var assert = _interopDefault(require('assert'));

// U is the subset of T, not sure why
// this works or why _T is necessary










// valid default schema
const defaultSchema = {
  last_reminder: 0,
  cached_at: 0,
  signature: '',
  version: '',
  output: {
    product: '',
    current_version: '',
    current_release_date: 0,
    current_download_url: '',
    current_changelog_url: '',
    install_command: '',
    project_website: '',
    outdated: false,
    alerts: [],
  },
};

// configure the configuration in a consistent way across processes
function configure(state) {
  return Config.new(state, defaultSchema)
}

// initialize the configuration
class Config {
  static new(state, defaultSchema) {
    makeDir.sync(path.dirname(state.cache_file));
    return new Config(state, defaultSchema)
  }

  // create the configuration synchronously
  static sync(state, schema = defaultSchema) {
    makeDir.sync(path.dirname(state.cache_file));
    return new Config(state, schema)
  }

  constructor(
      state,
      defaultSchema
  ) {this.state = state;this.defaultSchema = defaultSchema;}

  // set the configuration
  set(update) {
    const existing = this.all() || {};
    const schema = Object.assign(existing, update);
    // TODO: figure out how to type this
    for (let k in this.defaultSchema) {
      // @ts-ignore
      if (typeof schema[k] === 'undefined') {
        // @ts-ignore
        schema[k] = this.defaultSchema[k];
      }
    }
    fs.writeFileSync(this.state.cache_file, JSON.stringify(schema, null, '  '));
    return
  }

  // get the entire schema
  all() {
    try {
      const data = fs.readFileSync(this.state.cache_file, 'utf8');
      return JSON.parse(data)
    } catch (err) {
      return
    }
  }

  // get a value from the schema
  get(key) {
    const schema = this.all();
    if (typeof schema === 'undefined') {
      return
    }
    return schema[key]
  }

  // reset the configuration
  reset() {
    fs.writeFileSync(
      this.state.cache_file,
      JSON.stringify(this.defaultSchema, null, '  ')
    );
    return
  }

  // delete the configuration, ignoring any errors
  delete() {
    try {
      fs.unlinkSync(this.state.cache_file);
      return
    } catch (err) {
      return
    }
  }
}

// Check tests
describe('config/sync', () => {
  let config;

  // careful, these tests build off each other
  describe('set, all, get, reset, delete data', () => {
    before(async () => {
      const tmpfile = tempfile();
      config = configure({ cache_file: tmpfile });
    });

    it('initial state', async () => {
      assert.deepStrictEqual(await config.all(), undefined);
    });

    it('set one', async () => {
      await config.set({
        last_reminder: 10,
      });
      assert.deepStrictEqual(await config.all(), {
        last_reminder: 10,
        cached_at: 0,
        signature: '',
        version: '',
        output: {
          product: '',
          current_version: '',
          current_release_date: 0,
          current_download_url: '',
          current_changelog_url: '',
          install_command: '',
          project_website: '',
          outdated: false,
          alerts: [],
        },
      });
    });

    it('set many', async () => {
      await config.set({
        output: {
          product: '',
          current_version: '',
          current_release_date: 0,
          current_download_url: '',
          current_changelog_url: '',
          install_command: '',
          project_website: '',
          outdated: true,
          alerts: [],
        },
        version: '10',
      });
      assert.deepStrictEqual(await config.all(), {
        last_reminder: 10,
        cached_at: 0,
        signature: '',
        version: '10',
        output: {
          product: '',
          current_version: '',
          current_release_date: 0,
          current_download_url: '',
          current_changelog_url: '',
          install_command: '',
          project_website: '',
          outdated: true,
          alerts: [],
        },
      });
    });

    it('reset the output', async () => {
      // reset the response
      await config.set({
        output: undefined,
        version: '10',
      });
      assert.deepStrictEqual(await config.all(), {
        last_reminder: 10,
        cached_at: 0,
        signature: '',
        output: {
          product: '',
          current_version: '',
          current_release_date: 0,
          current_download_url: '',
          current_changelog_url: '',
          install_command: '',
          project_website: '',
          outdated: false,
          alerts: [],
        },
        version: '10',
      });
    });

    it('get existing', async () => {
      // get the version
      const version = await config.get('version');
      assert.equal(version, 10);
    });

    it('reset fields', async () => {
      // reset all fields
      await config.reset();
      assert.deepStrictEqual(await config.all(), {
        last_reminder: 0,
        cached_at: 0,
        signature: '',
        version: '',
        output: {
          product: '',
          current_version: '',
          current_release_date: 0,
          current_download_url: '',
          current_changelog_url: '',
          install_command: '',
          project_website: '',
          outdated: false,
          alerts: [],
        },
      });
    });

    it('deletes configuration', async () => {
      // delete the configuration
      await config.delete();
      assert.deepStrictEqual(await config.all(), undefined);
    });
  });
});
