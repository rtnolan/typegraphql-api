'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var makeDir = _interopDefault(require('make-dir'));
var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var paths = _interopDefault(require('env-paths'));
var crypto = _interopDefault(require('crypto'));
var tempfile = _interopDefault(require('tempfile'));
var assert = _interopDefault(require('assert'));

// U is the subset of T, not sure why
// this works or why _T is necessary










// valid default schema
const defaultSchema = {
  last_reminder: 0,
  cached_at: 0,
  signature: '',
  version: '',
  output: {
    product: '',
    current_version: '',
    current_release_date: 0,
    current_download_url: '',
    current_changelog_url: '',
    install_command: '',
    project_website: '',
    outdated: false,
    alerts: [],
  },
};

// configure the configuration in a consistent way across processes
function configure(state) {
  return Config.new(state, defaultSchema)
}

// initialize the configuration
class Config {
  static new(state, defaultSchema) {
    makeDir.sync(path.dirname(state.cache_file));
    return new Config(state, defaultSchema)
  }

  // create the configuration synchronously
  static sync(state, schema = defaultSchema) {
    makeDir.sync(path.dirname(state.cache_file));
    return new Config(state, schema)
  }

  constructor(
      state,
      defaultSchema
  ) {this.state = state;this.defaultSchema = defaultSchema;}

  // set the configuration
  set(update) {
    const existing = this.all() || {};
    const schema = Object.assign(existing, update);
    // TODO: figure out how to type this
    for (let k in this.defaultSchema) {
      // @ts-ignore
      if (typeof schema[k] === 'undefined') {
        // @ts-ignore
        schema[k] = this.defaultSchema[k];
      }
    }
    fs.writeFileSync(this.state.cache_file, JSON.stringify(schema, null, '  '));
    return
  }

  // get the entire schema
  all() {
    try {
      const data = fs.readFileSync(this.state.cache_file, 'utf8');
      return JSON.parse(data)
    } catch (err) {
      return
    }
  }

  // get a value from the schema
  get(key) {
    const schema = this.all();
    if (typeof schema === 'undefined') {
      return
    }
    return schema[key]
  }

  // reset the configuration
  reset() {
    fs.writeFileSync(
      this.state.cache_file,
      JSON.stringify(this.defaultSchema, null, '  ')
    );
    return
  }

  // delete the configuration, ignoring any errors
  delete() {
    try {
      fs.unlinkSync(this.state.cache_file);
      return
    } catch (err) {
      return
    }
  }
}

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.



var rng = function nodeRNG() {
  return crypto.randomBytes(16);
};

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

// This file was bolted on to give Prisma a consistent

const dirs = paths(`checkpoint`);
const defaultCache = path.join(dirs.cache, 'prisma');

function signature() {
  throw new Error('Not implemented yet')
}

// get the signature synchronously
signature.sync = function(cacheFile = defaultCache) {
  const cache = configure({ cache_file: cacheFile });
  let id = cache.get('signature');
  if (!id) {
    id = v4_1();
    cache.set({ signature: id });
  }
  return id
};

// Imports

// Check tests
describe('signature', () => {
  let tmpfile;
  beforeEach(() => {
    tmpfile = tempfile();
  });

  it('should return a consistent signature', () => {
    const uuid = signature.sync(tmpfile);
    assert.equal(typeof uuid, 'string');
    assert.equal(uuid.length, 36);
    assert.equal(uuid, signature.sync(tmpfile));
  });
});
