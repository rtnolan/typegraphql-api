"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const helpers_1 = require("../helpers");
const args_class_1 = tslib_1.__importDefault(require("../args-class"));
const config_1 = require("../config");
const imports_1 = require("../imports");
const saveSourceFile_1 = tslib_1.__importDefault(require("../../utils/saveSourceFile"));
async function generateRelationsResolverClassesFromModel(project, baseDirPath, model, mapping, outputType, modelNames) {
    const resolverName = `${model.name}RelationsResolver`;
    const rootArgName = helpers_1.camelCase(model.name);
    const relationFields = model.fields.filter(field => field.relationName);
    const singleIdField = model.fields.find(field => field.isId);
    const singleUniqueField = model.fields.find(field => field.isUnique);
    const singleFilterField = singleIdField !== null && singleIdField !== void 0 ? singleIdField : singleUniqueField;
    const compositeIdFields = model.fields.filter(field => model.idFields.includes(field.name));
    const compositeUniqueFields = model.fields.filter(field => { var _a; return (_a = 
    // taking first unique group is enough to fetch entity
    model.uniqueFields[0]) === null || _a === void 0 ? void 0 : _a.includes(field.name); });
    const compositeFilterFields = compositeIdFields.length > 0 ? compositeIdFields : compositeUniqueFields;
    const resolverDirPath = path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.relationsResolversFolderName, model.name);
    const filePath = path_1.default.resolve(resolverDirPath, `${resolverName}.ts`);
    const sourceFile = project.createSourceFile(filePath, undefined, {
        overwrite: true,
    });
    const methodsInfo = await Promise.all(relationFields.map(async (field) => {
        const outputTypeField = outputType.fields.find(it => it.name === field.name);
        // FIXME: remove when issue fixed: https://github.com/prisma/prisma2/issues/1987
        const fieldDocs = undefined;
        // const fieldDocs =
        //   field.documentation && field.documentation.replace("\r", "");
        const fieldType = helpers_1.getFieldTSType(field, modelNames);
        let argsTypeName;
        if (outputTypeField.args.length > 0) {
            argsTypeName = await args_class_1.default(project, resolverDirPath, outputTypeField.args, model.name + helpers_1.pascalCase(field.name), modelNames);
        }
        return { field, fieldDocs, fieldType, argsTypeName };
    }));
    const argTypeNames = methodsInfo
        .filter(it => it.argsTypeName !== undefined)
        .map(it => it.argsTypeName);
    const barrelExportSourceFile = project.createSourceFile(path_1.default.resolve(resolverDirPath, config_1.argsFolderName, "index.ts"), undefined, { overwrite: true });
    if (argTypeNames.length) {
        imports_1.generateArgsBarrelFile(barrelExportSourceFile, argTypeNames);
        await saveSourceFile_1.default(barrelExportSourceFile);
    }
    imports_1.generateTypeGraphQLImport(sourceFile);
    imports_1.generateModelsImports(sourceFile, [...relationFields.map(field => field.type), model.name], 3);
    imports_1.generateArgsImports(sourceFile, argTypeNames, 0);
    sourceFile.addClass({
        name: resolverName,
        isExported: true,
        decorators: [
            {
                name: "TypeGraphQL.Resolver",
                arguments: [`_of => ${helpers_1.getBaseModelTypeName(model.name)}`],
            },
        ],
        methods: methodsInfo.map(({ field, fieldType, fieldDocs, argsTypeName }) => {
            let whereConditionString = "";
            // TODO: refactor to AST
            if (singleFilterField) {
                whereConditionString = `
            ${singleFilterField.name}: ${rootArgName}.${singleFilterField.name},
          `;
            }
            else if (compositeFilterFields.length > 0) {
                whereConditionString = `
            ${compositeFilterFields.map(it => it.name).join("_")}: {
              ${compositeFilterFields
                    .map(idField => `${idField.name}: ${rootArgName}.${idField.name},`)
                    .join("\n")}
            },
          `;
            }
            else {
                throw new Error(`Unexpected error happened on generating 'whereConditionString' for ${model.name} relation resolver`);
            }
            return {
                name: field.name,
                isAsync: true,
                returnType: `Promise<${fieldType}>`,
                decorators: [
                    {
                        name: "TypeGraphQL.FieldResolver",
                        arguments: [
                            `_type => ${helpers_1.getTypeGraphQLType(field, modelNames)}`,
                            `{
                  nullable: ${!field.isRequired},
                  description: ${fieldDocs ? `"${fieldDocs}"` : "undefined"},
                }`,
                        ],
                    },
                ],
                parameters: [
                    {
                        name: rootArgName,
                        type: `${helpers_1.getBaseModelTypeName(model.name)}`,
                        decorators: [{ name: "TypeGraphQL.Root", arguments: [] }],
                    },
                    {
                        name: "ctx",
                        // TODO: import custom `ContextType`
                        type: "any",
                        decorators: [{ name: "TypeGraphQL.Ctx", arguments: [] }],
                    },
                    ...(!argsTypeName
                        ? []
                        : [
                            {
                                name: "args",
                                type: argsTypeName,
                                decorators: [{ name: "TypeGraphQL.Args", arguments: [] }],
                            },
                        ]),
                ],
                // TODO: refactor to AST
                statements: [
                    `return ctx.prisma.${helpers_1.camelCase(model.name)}.findOne({
              where: {${whereConditionString}},
            }).${field.name}(${argsTypeName ? "args" : "{}"});`,
                ],
            };
        }),
    });
    await saveSourceFile_1.default(sourceFile);
    return { modelName: model.name, resolverName, argTypeNames };
}
exports.default = generateRelationsResolverClassesFromModel;
//# sourceMappingURL=relations.js.map