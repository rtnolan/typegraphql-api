"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const helpers_1 = require("../helpers");
const config_1 = require("../config");
const args_class_1 = tslib_1.__importDefault(require("../args-class"));
const imports_1 = require("../imports");
const saveSourceFile_1 = tslib_1.__importDefault(require("../../utils/saveSourceFile"));
const separate_action_1 = tslib_1.__importDefault(require("./separate-action"));
const helpers_2 = require("./helpers");
async function generateCrudResolverClassFromMapping(project, baseDirPath, mapping, model, types, modelNames, options) {
    const resolverName = `${model.name}CrudResolver`;
    const collectionName = helpers_1.camelCase(mapping.model);
    const resolverDirPath = path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.crudResolversFolderName, model.name);
    const filePath = path_1.default.resolve(resolverDirPath, `${resolverName}.ts`);
    const sourceFile = project.createSourceFile(filePath, undefined, {
        overwrite: true,
    });
    imports_1.generateTypeGraphQLImport(sourceFile);
    const actionNames = Object.keys(mapping).filter(key => !config_1.baseKeys.includes(key));
    const supportedActionNames = actionNames.filter(actionName => getOperationKindName(actionName) !== undefined);
    const methodsInfo = await Promise.all(supportedActionNames.map(async (actionName) => {
        const operationKind = getOperationKindName(actionName);
        const fieldName = mapping[actionName];
        const type = types.find(type => type.fields.some(field => field.name === fieldName));
        if (!type) {
            throw new Error(`Cannot find type with field ${fieldName} in root types definitions!`);
        }
        const method = type.fields.find(field => field.name === fieldName);
        if (!method) {
            throw new Error(`Cannot find field ${fieldName} in output types definitions!`);
        }
        const outputTypeName = method.outputType.type;
        let argsTypeName;
        if (method.args.length > 0) {
            argsTypeName = await args_class_1.default(project, resolverDirPath, method.args, method.name, modelNames);
        }
        return {
            operationKind,
            method,
            actionName,
            outputTypeName,
            argsTypeName,
        };
    }));
    const argTypeNames = methodsInfo
        .filter(it => it.argsTypeName !== undefined)
        .map(it => it.argsTypeName);
    if (argTypeNames.length) {
        const barrelExportSourceFile = project.createSourceFile(path_1.default.resolve(resolverDirPath, config_1.argsFolderName, "index.ts"), undefined, { overwrite: true });
        imports_1.generateArgsBarrelFile(barrelExportSourceFile, methodsInfo
            .filter(it => it.argsTypeName !== undefined)
            .map(it => it.argsTypeName));
        await saveSourceFile_1.default(barrelExportSourceFile);
    }
    imports_1.generateArgsImports(sourceFile, argTypeNames, 0);
    const distinctOutputTypesNames = [
        ...new Set(methodsInfo.map(it => it.outputTypeName)),
    ];
    imports_1.generateModelsImports(sourceFile, distinctOutputTypesNames.filter(typeName => modelNames.includes(typeName)), 3);
    imports_1.generateOutputsImports(sourceFile, distinctOutputTypesNames.filter(typeName => !modelNames.includes(typeName)), 2);
    sourceFile.addClass({
        name: resolverName,
        isExported: true,
        decorators: [
            {
                name: "TypeGraphQL.Resolver",
                arguments: [`_of => ${model.name}`],
            },
        ],
        methods: await Promise.all(methodsInfo.map(({ operationKind, actionName, method, argsTypeName }) => helpers_2.generateCrudResolverClassMethodDeclaration(operationKind, actionName, method, argsTypeName, collectionName, modelNames, mapping, options))),
    });
    const actionResolverNames = await Promise.all(methodsInfo.map(({ operationKind, actionName, method, outputTypeName, argsTypeName }) => separate_action_1.default(project, baseDirPath, model, operationKind, actionName, method, outputTypeName, argsTypeName, collectionName, modelNames, mapping, options)));
    await saveSourceFile_1.default(sourceFile);
    return {
        modelName: model.name,
        resolverName,
        actionResolverNames,
        argTypeNames,
    };
}
exports.default = generateCrudResolverClassFromMapping;
function getOperationKindName(actionName) {
    if (config_1.supportedQueryActions.includes(actionName))
        return "Query";
    if (config_1.supportedMutationActions.includes(actionName))
        return "Mutation";
}
//# sourceMappingURL=full-crud.js.map