"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const helpers_1 = require("./helpers");
const config_1 = require("./config");
const imports_1 = require("./imports");
const saveSourceFile_1 = tslib_1.__importDefault(require("../utils/saveSourceFile"));
const args_class_1 = tslib_1.__importDefault(require("./args-class"));
async function generateOutputTypeClassFromType(project, dirPath, type, modelNames) {
    const fileDirPath = path_1.default.resolve(dirPath, config_1.outputsFolderName);
    const filePath = path_1.default.resolve(fileDirPath, `${type.name}.ts`);
    const sourceFile = project.createSourceFile(filePath, undefined, {
        overwrite: true,
    });
    const fieldsInfo = await Promise.all(type.fields.map(async (field) => {
        let argsTypeName;
        if (field.args.length > 0) {
            argsTypeName = await args_class_1.default(project, fileDirPath, field.args, `${type.name}${helpers_1.pascalCase(field.name)}`, modelNames, 2);
        }
        return { ...field, argsTypeName };
    }));
    const fieldArgsTypeNames = fieldsInfo
        .filter(it => it.argsTypeName)
        .map(it => it.argsTypeName);
    imports_1.generateTypeGraphQLImport(sourceFile);
    imports_1.generateArgsImports(sourceFile, fieldArgsTypeNames, 0);
    sourceFile.addClass({
        name: type.name,
        isExported: true,
        decorators: [
            {
                name: "TypeGraphQL.ObjectType",
                arguments: [
                    `{
            isAbstract: true,
            description: undefined,
          }`,
                ],
            },
        ],
        properties: fieldsInfo
            .filter(it => it.args.length === 0)
            .map(field => {
            const isRequired = field.outputType.isRequired;
            return {
                name: field.name,
                type: helpers_1.getFieldTSType(field.outputType, modelNames),
                hasExclamationToken: isRequired,
                hasQuestionToken: !isRequired,
                trailingTrivia: "\r\n",
                decorators: [
                    {
                        name: "TypeGraphQL.Field",
                        arguments: [
                            `_type => ${helpers_1.getTypeGraphQLType(field.outputType, modelNames)}`,
                            `{
                  nullable: ${!isRequired},
                  description: undefined
                }`,
                        ],
                    },
                ],
            };
        }),
        methods: fieldsInfo
            // TODO: allow also for other fields args
            .filter(it => it.args.length > 0 && type.name.startsWith("Aggregate"))
            .map(fieldInfo => {
            const isRequired = fieldInfo.outputType.isRequired;
            // TODO: make it more future-proof
            const collectionName = helpers_1.camelCase(type.name.replace("Aggregate", ""));
            return {
                name: fieldInfo.name,
                type: helpers_1.getFieldTSType(fieldInfo.outputType, modelNames),
                trailingTrivia: "\r\n",
                decorators: [
                    {
                        name: "TypeGraphQL.Field",
                        arguments: [
                            `_type => ${helpers_1.getTypeGraphQLType(fieldInfo.outputType, modelNames)}`,
                            `{
                  nullable: ${!isRequired},
                  description: undefined
                }`,
                        ],
                    },
                ],
                parameters: [
                    {
                        name: "ctx",
                        // TODO: import custom `ContextType`
                        type: "any",
                        decorators: [{ name: "TypeGraphQL.Ctx", arguments: [] }],
                    },
                    {
                        name: "args",
                        type: fieldInfo.argsTypeName,
                        decorators: [{ name: "TypeGraphQL.Args", arguments: [] }],
                    },
                ],
                statements: [
                    `return ctx.prisma.${collectionName}.${fieldInfo.name}(args);`,
                ],
            };
        }),
    });
    await saveSourceFile_1.default(sourceFile);
    return fieldArgsTypeNames;
}
exports.generateOutputTypeClassFromType = generateOutputTypeClassFromType;
async function generateInputTypeClassFromType(project, dirPath, type, modelNames) {
    const filePath = path_1.default.resolve(dirPath, config_1.inputsFolderName, `${type.name}.ts`);
    const sourceFile = project.createSourceFile(filePath, undefined, {
        overwrite: true,
    });
    imports_1.generateTypeGraphQLImport(sourceFile);
    imports_1.generateInputsImports(sourceFile, type.fields
        .map(field => helpers_1.selectInputTypeFromTypes(field.inputType))
        .filter(fieldType => fieldType.kind === "object")
        .map(fieldType => fieldType.type)
        .filter(fieldType => fieldType !== type.name));
    imports_1.generateEnumsImports(sourceFile, type.fields
        .map(field => helpers_1.selectInputTypeFromTypes(field.inputType))
        .filter(fieldType => fieldType.kind === "enum")
        .map(fieldType => fieldType.type), 2);
    sourceFile.addClass({
        name: type.name,
        isExported: true,
        decorators: [
            {
                name: "TypeGraphQL.InputType",
                arguments: [
                    `{
            isAbstract: true,
            description: undefined,
          }`,
                ],
            },
        ],
        properties: type.fields.map(field => {
            const inputType = helpers_1.selectInputTypeFromTypes(field.inputType);
            return {
                name: field.name,
                type: helpers_1.getFieldTSType(inputType, modelNames),
                hasExclamationToken: inputType.isRequired,
                hasQuestionToken: !inputType.isRequired,
                trailingTrivia: "\r\n",
                decorators: [
                    {
                        name: "TypeGraphQL.Field",
                        arguments: [
                            `_type => ${helpers_1.getTypeGraphQLType(inputType, modelNames)}`,
                            `{
                  nullable: ${!inputType.isRequired},
                  description: undefined
                }`,
                        ],
                    },
                ],
            };
        }),
    });
    await saveSourceFile_1.default(sourceFile);
}
exports.generateInputTypeClassFromType = generateInputTypeClassFromType;
//# sourceMappingURL=type-class.js.map