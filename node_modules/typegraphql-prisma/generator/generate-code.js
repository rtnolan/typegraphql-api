"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ts_morph_1 = require("ts-morph");
const path_1 = tslib_1.__importDefault(require("path"));
const helpers_1 = require("./helpers");
const enum_1 = tslib_1.__importDefault(require("./enum"));
const object_type_class_1 = tslib_1.__importDefault(require("./object-type-class"));
const relations_1 = tslib_1.__importDefault(require("./resolvers/relations"));
const type_class_1 = require("./type-class");
const full_crud_1 = tslib_1.__importDefault(require("./resolvers/full-crud"));
const config_1 = require("./config");
const imports_1 = require("./imports");
const saveSourceFile_1 = tslib_1.__importDefault(require("../utils/saveSourceFile"));
async function generateCode(dmmf, options, log = helpers_1.noop) {
    const baseDirPath = options.outputDirPath;
    const project = new ts_morph_1.Project();
    const resolversDirPath = path_1.default.resolve(baseDirPath, config_1.resolversFolderName);
    const modelNames = dmmf.datamodel.models.map(model => model.name);
    log("Generating enums...");
    const datamodelEnumNames = dmmf.datamodel.enums.map(enumDef => enumDef.name);
    await Promise.all(dmmf.datamodel.enums.map(enumDef => enum_1.default(project, baseDirPath, enumDef)));
    await Promise.all(dmmf.schema.enums
        // skip enums from datamodel
        .filter(enumDef => !datamodelEnumNames.includes(enumDef.name))
        .map(enumDef => enum_1.default(project, baseDirPath, enumDef)));
    const emittedEnumNames = [
        ...new Set([
            ...dmmf.schema.enums.map(it => it.name),
            ...dmmf.datamodel.enums.map(it => it.name),
        ]),
    ];
    const enumsBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.enumsFolderName, "index.ts"), undefined, { overwrite: true });
    imports_1.generateEnumsBarrelFile(enumsBarrelExportSourceFile, emittedEnumNames);
    await saveSourceFile_1.default(enumsBarrelExportSourceFile);
    log("Generating models...");
    await Promise.all(dmmf.datamodel.models.map(model => object_type_class_1.default(project, baseDirPath, model, modelNames)));
    const modelsBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.modelsFolderName, "index.ts"), undefined, { overwrite: true });
    imports_1.generateModelsBarrelFile(modelsBarrelExportSourceFile, dmmf.datamodel.models.map(it => it.name));
    await saveSourceFile_1.default(modelsBarrelExportSourceFile);
    log("Generating output types...");
    const rootTypes = dmmf.schema.outputTypes.filter(type => ["Query", "Mutation"].includes(type.name));
    const outputTypesToGenerate = dmmf.schema.outputTypes.filter(
    // skip generating models and root resolvers
    type => !modelNames.includes(type.name) && !rootTypes.includes(type));
    const argsTypesNamesArray = await Promise.all(outputTypesToGenerate.map(type => type_class_1.generateOutputTypeClassFromType(project, resolversDirPath, type, modelNames)));
    const argsTypesNames = argsTypesNamesArray.reduce((a, b) => a.concat(b), []);
    const outputsArgsBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.outputsFolderName, config_1.argsFolderName, "index.ts"), undefined, { overwrite: true });
    imports_1.generateArgsBarrelFile(outputsArgsBarrelExportSourceFile, argsTypesNames);
    await saveSourceFile_1.default(outputsArgsBarrelExportSourceFile);
    const outputsBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.outputsFolderName, "index.ts"), undefined, { overwrite: true });
    imports_1.generateOutputsBarrelFile(outputsBarrelExportSourceFile, outputTypesToGenerate.map(it => it.name), argsTypesNames.length > 0);
    await saveSourceFile_1.default(outputsBarrelExportSourceFile);
    log("Generating input types...");
    await Promise.all(dmmf.schema.inputTypes.map(type => type_class_1.generateInputTypeClassFromType(project, resolversDirPath, type, modelNames)));
    const inputsBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.inputsFolderName, "index.ts"), undefined, { overwrite: true });
    imports_1.generateInputsBarrelFile(inputsBarrelExportSourceFile, dmmf.schema.inputTypes.map(it => it.name));
    await saveSourceFile_1.default(inputsBarrelExportSourceFile);
    log("Generating relation resolvers...");
    const relationResolversData = await Promise.all(dmmf.datamodel.models
        .filter(model => model.fields.some(field => field.relationName))
        .map(model => {
        const outputType = dmmf.schema.outputTypes.find(type => type.name === model.name);
        const mapping = dmmf.mappings.find(it => it.model === model.name);
        return relations_1.default(project, baseDirPath, model, mapping, outputType, modelNames);
    }));
    if (relationResolversData.length > 0) {
        const relationResolversBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.relationsResolversFolderName, "index.ts"), undefined, { overwrite: true });
        imports_1.generateResolversBarrelFile("relations", relationResolversBarrelExportSourceFile, relationResolversData);
        await saveSourceFile_1.default(relationResolversBarrelExportSourceFile);
    }
    log("Generating crud resolvers...");
    const crudResolversData = await Promise.all(dmmf.mappings.map(mapping => {
        const model = dmmf.datamodel.models.find(model => model.name === mapping.model);
        return full_crud_1.default(project, baseDirPath, mapping, model, rootTypes, modelNames, options);
    }));
    const crudResolversBarrelExportSourceFile = project.createSourceFile(path_1.default.resolve(baseDirPath, config_1.resolversFolderName, config_1.crudResolversFolderName, "index.ts"), undefined, { overwrite: true });
    imports_1.generateResolversBarrelFile("crud", crudResolversBarrelExportSourceFile, crudResolversData);
    await saveSourceFile_1.default(crudResolversBarrelExportSourceFile);
    log("Generating index file");
    const indexSourceFile = project.createSourceFile(baseDirPath + "/index.ts", undefined, { overwrite: true });
    imports_1.generateIndexFile(indexSourceFile, relationResolversData.length > 0);
    await saveSourceFile_1.default(indexSourceFile);
}
exports.default = generateCode;
//# sourceMappingURL=generate-code.js.map